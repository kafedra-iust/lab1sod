= Лабораторна робота №1. Лінійні масиви. Пошук. Сортування

== Мета роботи: Навчитись розробляти програми, що використовують сортування та пошук, та аналізувати їхню ефективність

=== Завдання
.	Сформуйте масив з 10^5^ випадкових цілих чисел з діапазону [0, 10^5^+N*1000) (N – номер варіанту за списком групи).
.	Порахуйте кількість чисел у заданому масиві, що потрапляють у діапазон [N,2*N]
.	Визначте найменший індекс елементу масиву, що дорівнює 1000+N. Якщо масив не містить такого елементу, вивести -1.
.	Згідно з варіантом, розробіть програму, що виконує сортування створеного масиву. Метод сортування обрати згідно з таблицею. Виміряйте час роботи алгоритму сортування.
.	Згенеруйте масив аналогічно до п. 1 збільшивши кількість елементів масиву у 2 рази. Відсортуйте новий масив методом з п.4. Порівняйте час роботи сортування для двох масивів.
.	Повторіть завдання п.3 для відсортованого масиву, використовуючи алгоритм бінарного пошуку. Порівняйте кількість операцій порівнянь, які необхідно виконати для пошуку елементу у впорядкованому та невпорядкованому масиві.
. Порівняйте час, що потрібний для сортування різними способами і час, за який виконується сортування стандартним методом sort класу IntArray.
. Проаналізуйте метод пошуку максимального елемента методом "Розділяй і володарюй" - яка складність його буде?

|===
|Варіанти |Метод сортування

|1,4,7,10,13,16,19,22,25,28
|Метод вставки

|2,5,8,11,14,17,20,23,26,29
|Метод обмінів

|3,6,9,12,15,18,21,24,27,30
|Метод вибору

|===

=== Пояснення до виконання

Якщо завдання виконується мовою Java, для генерування масиву випадкових чисел можна скористатись методами генерації випадкових чисел класу Random:

`Random rnd = new Random();` - створення генератору випадкових чисел

`rnd.nextInt(bound);` – випадкове ціле число з діапазону [0, bound)

`rnd.ints(N, origin, bound).toArray();` – масив з N випадкових цілих чисел з діапазону [origin, bound)

Для вимірювання часу роботи програми можна скористатися методом currentTimeMillis() класу System. Це можна зробити за такою схемою:

[source,java]
----
long start = System.currentTimeMillis();
// обчислювальний процес, час роботи якого треба виміряти
long finish = System.currentTimeMillis();
System.out.println("Time = " + (finish-start));
----

Якщо завдання виконується мовою C&#43;&#43;, для генерування випадкових чисел доцільно використовувати описані в бібліотеці <random> механізми. Наприклад, так:

[source, c++]
----
// створюємо Генератор Псевдовипадкових Чисел та ініціалізуємо його значенням  time(0)
std::mt19937 gen(time(0));
// створюємо розподіл uid та ініціалізуємо його початковими значеннями
std::uniform_int_distribution<int> uid(0, 100_000);
// наша змінна отримує значення випадкового числа з указаного розподілу
int randomNumber = uid(gen)
----

_Використання функцій rand(), srand() не рекомендується, оскільки вони дають погану різноманітність даних та невеликий діапазон значень._

Якщо завдання виконується мовою Kotlin, можна скористатись наведеним у цьому проєкті шаблоном програми


Для вимірювання часу роботи програми можна скористатися методом currentTimeMillis() класу System. Це можна зробити за такою схемою:
[source,kotlin]
----
val start = System.currentTimeMillis()
// обчислювальний процес, час роботи якого треба виміряти
val finish = System.currentTimeMillis()
println("Time = ${finish - start}")
----

_Пошук максимуму методом "Розділяй і володарюй"_:

[source, kotlin]
----
fun findMaxBinary(array: IntArray) : Int? {
    return if (array.isEmpty()) {
        null
    } else findMax(array, 0, array.size - 1)
}

fun findMax(array: IntArray, low: Int, high: Int): Int {
    if (low == high) {
        return array[low]
    } else {
        val mid = (low + high) / 2
        val leftMax = findMax(array, low, mid)
        val rightMax = findMax(array, mid + 1, high)
        return maxOf(leftMax, rightMax)
    }
}
----
